{-# LANGUAGE ConstraintKinds             #-}
{-# LANGUAGE DataKinds                   #-}
{-# LANGUAGE KindSignatures              #-}
{-# LANGUAGE MultiParamTypeClasses       #-}
{-# LANGUAGE FlexibleInstances           #-}
{-# LANGUAGE TypeFamilies                #-}
{-# LANGUAGE CPP                         #-}


-- | An implementation of a cryptographic primitive is a method to
-- process data that is multiples of its block size. Fast
-- implementations involve other details like the alignment
-- restriction on the input buffer and all that. We package all this
-- in the following signature.
signature Implementation where

import Raaz.Core

# if MIN_VERSION_base(4,13,0)

import GHC.TypeLits

# endif

-- | The primitive for which the implementation is given
data Prim
-- | The internal memory used by the implementation.
data Internals

instance Primitive Prim
instance Memory Internals

-- | Name of the implementation.
name :: String

-- | Description of the implementation.
description :: String

# if MIN_VERSION_base(4,13,0)

-- | The alignment requirements on the buffer.
data BufferAlignment :: Nat
instance KnownNat BufferAlignment

# else
-- | The alignment required for buffer (hack around bug
-- https://ghc.haskell.org/trac/ghc/ticket/15138)
type BufferAlignment = 32
#endif

-- | The pointer type associated with the buffer used by the
-- implementation.
type BufferPtr = AlignedBlockPtr BufferAlignment Prim

-- | The additional space required in the buffer for processing the data.
additionalBlocks :: BlockCount Prim

-- | The function that process bytes in multiples of the block size of
-- the primitive.
processBlocks :: BufferPtr
              -> BlockCount Prim
              -> Internals
              -> IO ()

-- | Process the last bytes of the stream.
processLast :: BufferPtr
            -> BYTES Int
            -> Internals
            -> IO ()
