-- | This module exposes the low level details of pseudo-random
-- generator built out of an implementation of a pseudo-random
-- generator.
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE DataKinds        #-}
module PRGState
       ( RandomState, reseed, fillRandomBytes
       -- ** Information about the cryptographic generator.
       , csprgName, csprgDescription
       ) where

import Control.Monad.Reader
import Entropy (getEntropy)
import Prelude

import Raaz.Core

import Implementation
import Utils


-- | Name of the csprg used for stretching the seed.
csprgName :: String
csprgName = name

-- | A short description of the csprg.
csprgDescription :: String
csprgDescription = description

-- | The buffer to store randomness.
type RandomBuffer = Buffer RandomBufferSize

-- | Memory for storing the csprg state.
data RandomState = RandomState { internals       :: Internals
                               , auxBuffer       :: RandomBuffer
                               , remainingBytes  :: MemoryCell (BYTES Int)
                               , blocksGenerated :: MemoryCell (BLOCKS Prim)
                               }


instance Memory RandomState where
  memoryAlloc     = RandomState <$> memoryAlloc <*> memoryAlloc <*> memoryAlloc <*> memoryAlloc
  unsafeToPointer = unsafeToPointer  . internals

-------------------------------- The PRG operations ---------------------------------------------

-- | This function generates new random bytes just like
-- `newSample`. However, it fills the state with entropy form the
-- system if required.
sampleWithSeedIfReq :: MT RandomState ()
sampleWithSeedIfReq = do
  nGenBlocks <- getGenBlocks
  if nGenBlocks >= reseedAfter
    then clearBlocks >> reseed
    else newSample
  where getGenBlocks = withReaderT blocksGenerated extract
        clearBlocks = withReaderT blocksGenerated $ initialise (blocksOf 0 (Proxy :: Proxy Prim))

-- | Reseed the prg from the system entropy pool.
reseed :: MT RandomState ()
reseed = runOnInternals initFromEntropyPool >> newSample
  where initFromEntropyPool = withMemoryPtr getEntropy

-- | This fills in the auxiliary buffer with some generated bytes. A
-- portion of this generated bytes is used to re-initialise the
-- Internal memory so that an accidental revelation of the state will
-- not compromise the past bytes that are generated.
newSample :: MT RandomState ()
newSample = generateRandom >> reInitStateFromBuffer

-- | Generate random bytes into the buffer in one go which will then
-- be slowly released to the outside world. We need to do some book
-- keeping here namely, updating the total bytes remaining and the
-- total number of blocks of the primitive generated.
generateRandom :: MT RandomState ()
generateRandom = withAuxBuffer csprgBuf
                 >> updateGenBlocks
                 >> setRemainingBytes howMuch
  where csprgBuf bufPtr = withReaderT internals $ randomBlocks bufPtr howMuch
        updateGenBlocks = withReaderT blocksGenerated $ modify (mappend howMuch)
        howMuch         = bufferSize (Proxy :: Proxy RandomBuffer)


-- | Re-initialise the internal state from the auxiliary buffer.
reInitStateFromBuffer :: MT RandomState ()
reInitStateFromBuffer = do
  rdr <- initialiser <$> runOnInternals ask
  let nbytes = transferSize rdr
    in unsafeWithExisting nbytes (runOnInternals . unsafeTransfer rdr)

-------------------------- Some helper functions on random state -------------------

-- | Run an action on the auxilary buffer.
withAuxBuffer :: (BufferPtr -> MT RandomState a) -> MT RandomState a
withAuxBuffer action = askBufferPointer >>= action
  where askBufferPointer = asks $ getBufferPointer . auxBuffer

runOnInternals :: MT Internals a -> MT RandomState a
runOnInternals = withReaderT internals

-- | Get the number of bytes in the buffer.
getRemainingBytes :: MT RandomState (BYTES Int)
getRemainingBytes = withReaderT remainingBytes extract

-- | Set the number of remaining bytes.
setRemainingBytes :: LengthUnit l => l -> MT RandomState ()
setRemainingBytes = withReaderT remainingBytes . initialise . inBytes



--------------------------- DANGEROUS CODE ---------------------------------------

-- NONTRIVIALITY: Picking up the newSample is important when we first
-- reseed.

-- | The function to generate random bytes. Fills from existing bytes
-- and continues if not enough bytes are obtained.
fillRandomBytes :: LengthUnit l => l -> Pointer -> MT RandomState ()
fillRandomBytes l = go (inBytes l)
  where go m ptr
          | m > 0     = do mGot <- fillExistingBytes m ptr   -- Fill from the already generated buffer.
                           when (mGot <= 0) sampleWithSeedIfReq
                           go (m - mGot) $ movePtr ptr mGot  -- Get the remaining.
          | otherwise = return ()   -- Nothing to do


-- | Fill from already existing bytes. Returns the number of bytes
-- filled. Let remaining bytes be r. Then fillExistingBytes will fill
-- min(r,m) bytes into the buffer, and return the number of bytes
-- filled.
fillExistingBytes :: BYTES Int -> Pointer -> MT RandomState (BYTES Int)
fillExistingBytes req ptr = do
  r <- getRemainingBytes
  let m = min r req
    in do unsafeWithExisting m (\ sPtr -> memcpy (destination ptr) (source sPtr) m)
          return m

-- | Transfer from existing bytes. This is unsafe because no checks is
-- done to see if there are enough bytes to transfer.
unsafeWithExisting :: BYTES Int
                   -> (Pointer -> MT RandomState ())
                   -> MT RandomState ()
unsafeWithExisting m action =  withAuxBuffer $ \ buf -> do
  r <- getRemainingBytes
  let sptr    = forgetAlignment buf --
      l       = r - m               -- leftovers
      tailPtr = movePtr sptr l
      in do
    -- Fills the source ptr from the end.
    --  sptr                tailPtr
    --   |                  |
    --   V                  V
    --   -----------------------------------------------------
    --   |   l              |    m                           |
    --   -----------------------------------------------------
    action tailPtr          -- run the transfer action from the tail.
    wipeMemory tailPtr m    -- wipe the bytes already transfered.
    setRemainingBytes l     -- set leftover bytes.
